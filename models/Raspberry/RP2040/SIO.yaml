# Created from RP2040.svd (Rev 0)

name: SIO
description: "Single-cycle IO block \n            Provides core-local and inter-core
  hardware for the two processors, with single-cycle access."
registers:
  - name: CPUID
    addressOffset: 0
    description: Processor core identifier
    resetMask: 0
    fields:
      - name: CPUID
        description: Value is 0 when read from processor core 0, and 1 when read
          from processor core 1.
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: GPIO_IN
    addressOffset: 4
    description: Input value for GPIO pins
    resetValue: 0
    fields:
      - name: GPIO_IN
        description: Input value for GPIO0...29
        access: read-only
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_HI_IN
    addressOffset: 8
    description: Input value for QSPI pins
    resetValue: 0
    fields:
      - name: GPIO_HI_IN
        description: 'Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2,
          SD3'
        access: read-only
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_OUT
    addressOffset: 16
    description: GPIO output value
    resetValue: 0
    fields:
      - name: GPIO_OUT
        description: "Set output level (1/0 -> high/low) for GPIO0...29. \n      \
          \                      Reading back gives the last value written, NOT the
          input value from the pins. \n                            If core 0 and core
          1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias), \n\
          \                            the result is as though the write from core
          0 took place first, \n                            and the write from core
          1 was then applied to that intermediate result."
        access: read-write
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_OUT_SET
    addressOffset: 20
    description: GPIO output value set
    resetValue: 0
    fields:
      - name: GPIO_OUT_SET
        description: Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= 
          wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_OUT_CLR
    addressOffset: 24
    description: GPIO output value clear
    resetValue: 0
    fields:
      - name: GPIO_OUT_CLR
        description: Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= 
          ~wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_OUT_XOR
    addressOffset: 28
    description: GPIO output value XOR
    resetValue: 0
    fields:
      - name: GPIO_OUT_XOR
        description: Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT 
          ^= wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_OE
    addressOffset: 32
    description: GPIO output enable
    resetValue: 0
    fields:
      - name: GPIO_OE
        description: "Set output enable (1/0 -> output/input) for GPIO0...29. \n \
          \                           Reading back gives the last value written. \n\
          \                            If core 0 and core 1 both write to GPIO_OE
          simultaneously (or to a SET/CLR/XOR alias), \n                         \
          \   the result is as though the write from core 0 took place first, \n \
          \                           and the write from core 1 was then applied to
          that intermediate result."
        access: read-write
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_OE_SET
    addressOffset: 36
    description: GPIO output enable set
    resetValue: 0
    fields:
      - name: GPIO_OE_SET
        description: Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= 
          wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_OE_CLR
    addressOffset: 40
    description: GPIO output enable clear
    resetValue: 0
    fields:
      - name: GPIO_OE_CLR
        description: Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= 
          ~wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_OE_XOR
    addressOffset: 44
    description: GPIO output enable XOR
    resetValue: 0
    fields:
      - name: GPIO_OE_XOR
        description: Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= 
          wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 30
  - name: GPIO_HI_OUT
    addressOffset: 48
    description: QSPI output value
    resetValue: 0
    fields:
      - name: GPIO_HI_OUT
        description: "Set output level (1/0 -> high/low) for QSPI IO0...5. \n    \
          \                        Reading back gives the last value written, NOT
          the input value from the pins. \n                            If core 0 and
          core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias),\
          \ \n                            the result is as though the write from core
          0 took place first, \n                            and the write from core
          1 was then applied to that intermediate result."
        access: read-write
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_HI_OUT_SET
    addressOffset: 52
    description: QSPI output value set
    resetValue: 0
    fields:
      - name: GPIO_HI_OUT_SET
        description: Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT
          |= wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_HI_OUT_CLR
    addressOffset: 56
    description: QSPI output value clear
    resetValue: 0
    fields:
      - name: GPIO_HI_OUT_CLR
        description: Perform an atomic bit-clear on GPIO_HI_OUT, i.e. 
          `GPIO_HI_OUT &= ~wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_HI_OUT_XOR
    addressOffset: 60
    description: QSPI output value XOR
    resetValue: 0
    fields:
      - name: GPIO_HI_OUT_XOR
        description: Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. 
          `GPIO_HI_OUT ^= wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_HI_OE
    addressOffset: 64
    description: QSPI output enable
    resetValue: 0
    fields:
      - name: GPIO_HI_OE
        description: "Set output enable (1/0 -> output/input) for QSPI IO0...5. \n\
          \                            Reading back gives the last value written.\
          \ \n                            If core 0 and core 1 both write to GPIO_HI_OE
          simultaneously (or to a SET/CLR/XOR alias), \n                         \
          \   the result is as though the write from core 0 took place first, \n \
          \                           and the write from core 1 was then applied to
          that intermediate result."
        access: read-write
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_HI_OE_SET
    addressOffset: 68
    description: QSPI output enable set
    resetValue: 0
    fields:
      - name: GPIO_HI_OE_SET
        description: Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE 
          |= wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_HI_OE_CLR
    addressOffset: 72
    description: QSPI output enable clear
    resetValue: 0
    fields:
      - name: GPIO_HI_OE_CLR
        description: Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE
          &= ~wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 6
  - name: GPIO_HI_OE_XOR
    addressOffset: 76
    description: QSPI output enable XOR
    resetValue: 0
    fields:
      - name: GPIO_HI_OE_XOR
        description: Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. 
          `GPIO_HI_OE ^= wdata`
        access: write-only
        bitOffset: 0
        bitWidth: 6
  - name: FIFO_ST
    addressOffset: 80
    description: "Status register for inter-core FIFOs (mailboxes). \n           \
      \         There is one FIFO in the core 0 -> core 1 direction, and one core
      1 -> core 0. Both are 32 bits wide and 8 words deep. \n                    Core
      0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO
      (TX). \n                    Core 1 can see the read side of the 0->1 FIFO (RX),
      and the write side of 1->0 FIFO (TX). \n                    The SIO IRQ for
      each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register."
    resetValue: 2
    fields:
      - name: VLD
        description: Value is 1 if this core's RX FIFO is not empty (i.e. if 
          FIFO_RD is valid)
        access: read-only
        bitOffset: 0
        bitWidth: 1
      - name: RDY
        description: Value is 1 if this core's TX FIFO is not full (i.e. if 
          FIFO_WR is ready for more data)
        access: read-only
        bitOffset: 1
        bitWidth: 1
      - name: WOF
        description: Sticky flag indicating the TX FIFO was written when full. 
          This write was ignored by the FIFO.
        access: read-write
        modifiedWriteValues: oneToClear
        bitOffset: 2
        bitWidth: 1
      - name: ROE
        description: Sticky flag indicating the RX FIFO was read when empty. 
          This read was ignored by the FIFO.
        access: read-write
        modifiedWriteValues: oneToClear
        bitOffset: 3
        bitWidth: 1
  - name: FIFO_WR
    addressOffset: 84
    description: Write access to this core's TX FIFO
    resetValue: 0
    fields:
      - name: FIFO_WR
        access: write-only
        bitOffset: 0
        bitWidth: 32
  - name: FIFO_RD
    addressOffset: 88
    description: Read access to this core's RX FIFO
    resetMask: 0
    fields:
      - name: FIFO_RD
        access: read-only
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK_ST
    addressOffset: 92
    description: "Spinlock state \n                    A bitmap containing the state
      of all 32 spinlocks (1=locked). \n                    Mainly intended for debugging."
    resetValue: 0
    fields:
      - name: SPINLOCK_ST
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: DIV_UDIVIDEND
    addressOffset: 96
    description: "Divider unsigned dividend \n                    Write to the DIVIDEND
      operand of the divider, i.e. the p in `p / q`. \n                    Any operand
      write starts a new calculation. The results appear in QUOTIENT, REMAINDER. \n\
      \                    UDIVIDEND/SDIVIDEND are aliases of the same internal register.
      The U alias starts an \n                    unsigned calculation, and the S
      alias starts a signed calculation."
    resetValue: 0
    fields:
      - name: DIV_UDIVIDEND
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: DIV_UDIVISOR
    addressOffset: 100
    description: "Divider unsigned divisor \n                    Write to the DIVISOR
      operand of the divider, i.e. the q in `p / q`. \n                    Any operand
      write starts a new calculation. The results appear in QUOTIENT, REMAINDER. \n\
      \                    UDIVISOR/SDIVISOR are aliases of the same internal register.
      The U alias starts an \n                    unsigned calculation, and the S
      alias starts a signed calculation."
    resetValue: 0
    fields:
      - name: DIV_UDIVISOR
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: DIV_SDIVIDEND
    addressOffset: 104
    description: "Divider signed dividend \n                    The same as UDIVIDEND,
      but starts a signed calculation, rather than unsigned."
    resetValue: 0
    fields:
      - name: DIV_SDIVIDEND
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: DIV_SDIVISOR
    addressOffset: 108
    description: "Divider signed divisor \n                    The same as UDIVISOR,
      but starts a signed calculation, rather than unsigned."
    resetValue: 0
    fields:
      - name: DIV_SDIVISOR
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: DIV_QUOTIENT
    addressOffset: 112
    description: "Divider result quotient \n                    The result of `DIVIDEND
      / DIVISOR` (division). Contents undefined while CSR_READY is low. \n       \
      \             For signed calculations, QUOTIENT is negative when the signs of
      DIVIDEND and DIVISOR differ. \n                    This register can be written
      to directly, for context save/restore purposes. This halts any \n          \
      \          in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.\
      \ \n                    Reading from QUOTIENT clears the CSR_DIRTY flag, so
      should read results in the order \n                    REMAINDER, QUOTIENT if
      CSR_DIRTY is used."
    resetValue: 0
    fields:
      - name: DIV_QUOTIENT
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: DIV_REMAINDER
    addressOffset: 116
    description: "Divider result remainder \n                    The result of `DIVIDEND
      % DIVISOR` (modulo). Contents undefined while CSR_READY is low. \n         \
      \           For signed calculations, REMAINDER is negative only when DIVIDEND
      is negative. \n                    This register can be written to directly,
      for context save/restore purposes. This halts any \n                    in-progress
      calculation and sets the CSR_READY and CSR_DIRTY flags."
    resetValue: 0
    fields:
      - name: DIV_REMAINDER
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: DIV_CSR
    addressOffset: 120
    description: Control and status register for divider.
    resetValue: 1
    fields:
      - name: READY
        description: "Reads as 0 when a calculation is in progress, 1 otherwise. \n\
          \                            Writing an operand (xDIVIDEND, xDIVISOR) will
          immediately start a new calculation, no \n                            matter
          if one is already in progress. \n                            Writing to
          a result register will immediately terminate any in-progress calculation\
          \ \n                            and set the READY and DIRTY flags."
        access: read-only
        bitOffset: 0
        bitWidth: 1
      - name: DIRTY
        description: "Changes to 1 when any register is written, and back to 0 when
          QUOTIENT is read. \n                            Software can use this flag
          to make save/restore more efficient (skip if not DIRTY). \n            \
          \                If the flag is used in this way, it's recommended to either
          read QUOTIENT only, \n                            or REMAINDER and then
          QUOTIENT, to prevent data loss on context switch."
        access: read-only
        bitOffset: 1
        bitWidth: 1
  - name: INTERP0_ACCUM0
    addressOffset: 128
    description: Read/write access to accumulator 0
    resetValue: 0
    fields:
      - name: INTERP0_ACCUM0
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_ACCUM1
    addressOffset: 132
    description: Read/write access to accumulator 1
    resetValue: 0
    fields:
      - name: INTERP0_ACCUM1
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_BASE0
    addressOffset: 136
    description: Read/write access to BASE0 register.
    resetValue: 0
    fields:
      - name: INTERP0_BASE0
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_BASE1
    addressOffset: 140
    description: Read/write access to BASE1 register.
    resetValue: 0
    fields:
      - name: INTERP0_BASE1
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_BASE2
    addressOffset: 144
    description: Read/write access to BASE2 register.
    resetValue: 0
    fields:
      - name: INTERP0_BASE2
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_POP_LANE0
    addressOffset: 148
    description: Read LANE0 result, and simultaneously write lane results to 
      both accumulators (POP).
    resetValue: 0
    fields:
      - name: INTERP0_POP_LANE0
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_POP_LANE1
    addressOffset: 152
    description: Read LANE1 result, and simultaneously write lane results to 
      both accumulators (POP).
    resetValue: 0
    fields:
      - name: INTERP0_POP_LANE1
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_POP_FULL
    addressOffset: 156
    description: Read FULL result, and simultaneously write lane results to both
      accumulators (POP).
    resetValue: 0
    fields:
      - name: INTERP0_POP_FULL
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_PEEK_LANE0
    addressOffset: 160
    description: Read LANE0 result, without altering any internal state (PEEK).
    resetValue: 0
    fields:
      - name: INTERP0_PEEK_LANE0
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_PEEK_LANE1
    addressOffset: 164
    description: Read LANE1 result, without altering any internal state (PEEK).
    resetValue: 0
    fields:
      - name: INTERP0_PEEK_LANE1
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_PEEK_FULL
    addressOffset: 168
    description: Read FULL result, without altering any internal state (PEEK).
    resetValue: 0
    fields:
      - name: INTERP0_PEEK_FULL
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP0_CTRL_LANE0
    addressOffset: 172
    description: Control register for lane 0
    resetValue: 0
    fields:
      - name: SHIFT
        description: Logical right-shift applied to accumulator before masking
        access: read-write
        bitOffset: 0
        bitWidth: 5
      - name: MASK_LSB
        description: The least-significant bit allowed to pass by the mask 
          (inclusive)
        access: read-write
        bitOffset: 5
        bitWidth: 5
      - name: MASK_MSB
        description: "The most-significant bit allowed to pass by the mask (inclusive)\
          \ \n                            Setting MSB < LSB may cause chip to turn
          inside-out"
        access: read-write
        bitOffset: 10
        bitWidth: 5
      - name: SIGNED
        description: "If SIGNED is set, the shifted and masked accumulator value is
          sign-extended to 32 bits \n                            before adding to
          BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor."
        access: read-write
        bitOffset: 15
        bitWidth: 1
      - name: CROSS_INPUT
        description: "If 1, feed the opposite lane's accumulator into this lane's
          shift + mask hardware. \n                            Takes effect even if
          ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"
        access: read-write
        bitOffset: 16
        bitWidth: 1
      - name: CROSS_RESULT
        description: If 1, feed the opposite lane's result into this lane's 
          accumulator on POP.
        access: read-write
        bitOffset: 17
        bitWidth: 1
      - name: ADD_RAW
        description: If 1, mask + shift is bypassed for LANE0 result. This does 
          not affect FULL result.
        access: read-write
        bitOffset: 18
        bitWidth: 1
      - name: FORCE_MSB
        description: "ORed into bits 29:28 of the lane result presented to the processor
          on the bus. \n                            No effect on the internal 32-bit
          datapath. Handy for using a lane to generate sequence \n               \
          \             of pointers into flash or SRAM."
        access: read-write
        bitOffset: 19
        bitWidth: 2
      - name: BLEND
        description: "Only present on INTERP0 on each core. If BLEND mode is enabled:\
          \ \n                            - LANE1 result is a linear interpolation
          between BASE0 and BASE1, controlled \n                            by the
          8 LSBs of lane 1 shift and mask value (a fractional number between \n  \
          \                          0 and 255/256ths) \n                        \
          \    - LANE0 result does not have BASE0 added (yields only the 8 LSBs of
          lane 1 shift+mask value) \n                            - FULL result does
          not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask) \n  \
          \                          LANE1 SIGNED flag controls whether the interpolation
          is signed or unsigned."
        access: read-write
        bitOffset: 21
        bitWidth: 1
      - name: OVERF0
        description: Indicates if any masked-off MSBs in ACCUM0 are set.
        access: read-only
        bitOffset: 23
        bitWidth: 1
      - name: OVERF1
        description: Indicates if any masked-off MSBs in ACCUM1 are set.
        access: read-only
        bitOffset: 24
        bitWidth: 1
      - name: OVERF
        description: Set if either OVERF0 or OVERF1 is set.
        access: read-only
        bitOffset: 25
        bitWidth: 1
  - name: INTERP0_CTRL_LANE1
    addressOffset: 176
    description: Control register for lane 1
    resetValue: 0
    fields:
      - name: SHIFT
        description: Logical right-shift applied to accumulator before masking
        access: read-write
        bitOffset: 0
        bitWidth: 5
      - name: MASK_LSB
        description: The least-significant bit allowed to pass by the mask 
          (inclusive)
        access: read-write
        bitOffset: 5
        bitWidth: 5
      - name: MASK_MSB
        description: "The most-significant bit allowed to pass by the mask (inclusive)\
          \ \n                            Setting MSB < LSB may cause chip to turn
          inside-out"
        access: read-write
        bitOffset: 10
        bitWidth: 5
      - name: SIGNED
        description: "If SIGNED is set, the shifted and masked accumulator value is
          sign-extended to 32 bits \n                            before adding to
          BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor."
        access: read-write
        bitOffset: 15
        bitWidth: 1
      - name: CROSS_INPUT
        description: "If 1, feed the opposite lane's accumulator into this lane's
          shift + mask hardware. \n                            Takes effect even if
          ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"
        access: read-write
        bitOffset: 16
        bitWidth: 1
      - name: CROSS_RESULT
        description: If 1, feed the opposite lane's result into this lane's 
          accumulator on POP.
        access: read-write
        bitOffset: 17
        bitWidth: 1
      - name: ADD_RAW
        description: If 1, mask + shift is bypassed for LANE1 result. This does 
          not affect FULL result.
        access: read-write
        bitOffset: 18
        bitWidth: 1
      - name: FORCE_MSB
        description: "ORed into bits 29:28 of the lane result presented to the processor
          on the bus. \n                            No effect on the internal 32-bit
          datapath. Handy for using a lane to generate sequence \n               \
          \             of pointers into flash or SRAM."
        access: read-write
        bitOffset: 19
        bitWidth: 2
  - name: INTERP0_ACCUM0_ADD
    addressOffset: 180
    description: "Values written here are atomically added to ACCUM0 \n          \
      \          Reading yields lane 0's raw shift and mask value (BASE0 not added)."
    resetValue: 0
    fields:
      - name: INTERP0_ACCUM0_ADD
        access: read-write
        bitOffset: 0
        bitWidth: 24
  - name: INTERP0_ACCUM1_ADD
    addressOffset: 184
    description: "Values written here are atomically added to ACCUM1 \n          \
      \          Reading yields lane 1's raw shift and mask value (BASE1 not added)."
    resetValue: 0
    fields:
      - name: INTERP0_ACCUM1_ADD
        access: read-write
        bitOffset: 0
        bitWidth: 24
  - name: INTERP0_BASE_1AND0
    addressOffset: 188
    description: "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\
      \ \n                    Each half is sign-extended to 32 bits if that lane's
      SIGNED flag is set."
    resetValue: 0
    fields:
      - name: INTERP0_BASE_1AND0
        access: write-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_ACCUM0
    addressOffset: 192
    description: Read/write access to accumulator 0
    resetValue: 0
    fields:
      - name: INTERP1_ACCUM0
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_ACCUM1
    addressOffset: 196
    description: Read/write access to accumulator 1
    resetValue: 0
    fields:
      - name: INTERP1_ACCUM1
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_BASE0
    addressOffset: 200
    description: Read/write access to BASE0 register.
    resetValue: 0
    fields:
      - name: INTERP1_BASE0
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_BASE1
    addressOffset: 204
    description: Read/write access to BASE1 register.
    resetValue: 0
    fields:
      - name: INTERP1_BASE1
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_BASE2
    addressOffset: 208
    description: Read/write access to BASE2 register.
    resetValue: 0
    fields:
      - name: INTERP1_BASE2
        access: read-write
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_POP_LANE0
    addressOffset: 212
    description: Read LANE0 result, and simultaneously write lane results to 
      both accumulators (POP).
    resetValue: 0
    fields:
      - name: INTERP1_POP_LANE0
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_POP_LANE1
    addressOffset: 216
    description: Read LANE1 result, and simultaneously write lane results to 
      both accumulators (POP).
    resetValue: 0
    fields:
      - name: INTERP1_POP_LANE1
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_POP_FULL
    addressOffset: 220
    description: Read FULL result, and simultaneously write lane results to both
      accumulators (POP).
    resetValue: 0
    fields:
      - name: INTERP1_POP_FULL
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_PEEK_LANE0
    addressOffset: 224
    description: Read LANE0 result, without altering any internal state (PEEK).
    resetValue: 0
    fields:
      - name: INTERP1_PEEK_LANE0
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_PEEK_LANE1
    addressOffset: 228
    description: Read LANE1 result, without altering any internal state (PEEK).
    resetValue: 0
    fields:
      - name: INTERP1_PEEK_LANE1
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_PEEK_FULL
    addressOffset: 232
    description: Read FULL result, without altering any internal state (PEEK).
    resetValue: 0
    fields:
      - name: INTERP1_PEEK_FULL
        access: read-only
        bitOffset: 0
        bitWidth: 32
  - name: INTERP1_CTRL_LANE0
    addressOffset: 236
    description: Control register for lane 0
    resetValue: 0
    fields:
      - name: SHIFT
        description: Logical right-shift applied to accumulator before masking
        access: read-write
        bitOffset: 0
        bitWidth: 5
      - name: MASK_LSB
        description: The least-significant bit allowed to pass by the mask 
          (inclusive)
        access: read-write
        bitOffset: 5
        bitWidth: 5
      - name: MASK_MSB
        description: "The most-significant bit allowed to pass by the mask (inclusive)\
          \ \n                            Setting MSB < LSB may cause chip to turn
          inside-out"
        access: read-write
        bitOffset: 10
        bitWidth: 5
      - name: SIGNED
        description: "If SIGNED is set, the shifted and masked accumulator value is
          sign-extended to 32 bits \n                            before adding to
          BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor."
        access: read-write
        bitOffset: 15
        bitWidth: 1
      - name: CROSS_INPUT
        description: "If 1, feed the opposite lane's accumulator into this lane's
          shift + mask hardware. \n                            Takes effect even if
          ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"
        access: read-write
        bitOffset: 16
        bitWidth: 1
      - name: CROSS_RESULT
        description: If 1, feed the opposite lane's result into this lane's 
          accumulator on POP.
        access: read-write
        bitOffset: 17
        bitWidth: 1
      - name: ADD_RAW
        description: If 1, mask + shift is bypassed for LANE0 result. This does 
          not affect FULL result.
        access: read-write
        bitOffset: 18
        bitWidth: 1
      - name: FORCE_MSB
        description: "ORed into bits 29:28 of the lane result presented to the processor
          on the bus. \n                            No effect on the internal 32-bit
          datapath. Handy for using a lane to generate sequence \n               \
          \             of pointers into flash or SRAM."
        access: read-write
        bitOffset: 19
        bitWidth: 2
      - name: CLAMP
        description: "Only present on INTERP1 on each core. If CLAMP mode is enabled:\
          \ \n                            - LANE0 result is shifted and masked ACCUM0,
          clamped by a lower bound of \n                            BASE0 and an upper
          bound of BASE1. \n                            - Signedness of these comparisons
          is determined by LANE0_CTRL_SIGNED"
        access: read-write
        bitOffset: 22
        bitWidth: 1
      - name: OVERF0
        description: Indicates if any masked-off MSBs in ACCUM0 are set.
        access: read-only
        bitOffset: 23
        bitWidth: 1
      - name: OVERF1
        description: Indicates if any masked-off MSBs in ACCUM1 are set.
        access: read-only
        bitOffset: 24
        bitWidth: 1
      - name: OVERF
        description: Set if either OVERF0 or OVERF1 is set.
        access: read-only
        bitOffset: 25
        bitWidth: 1
  - name: INTERP1_CTRL_LANE1
    addressOffset: 240
    description: Control register for lane 1
    resetValue: 0
    fields:
      - name: SHIFT
        description: Logical right-shift applied to accumulator before masking
        access: read-write
        bitOffset: 0
        bitWidth: 5
      - name: MASK_LSB
        description: The least-significant bit allowed to pass by the mask 
          (inclusive)
        access: read-write
        bitOffset: 5
        bitWidth: 5
      - name: MASK_MSB
        description: "The most-significant bit allowed to pass by the mask (inclusive)\
          \ \n                            Setting MSB < LSB may cause chip to turn
          inside-out"
        access: read-write
        bitOffset: 10
        bitWidth: 5
      - name: SIGNED
        description: "If SIGNED is set, the shifted and masked accumulator value is
          sign-extended to 32 bits \n                            before adding to
          BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor."
        access: read-write
        bitOffset: 15
        bitWidth: 1
      - name: CROSS_INPUT
        description: "If 1, feed the opposite lane's accumulator into this lane's
          shift + mask hardware. \n                            Takes effect even if
          ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"
        access: read-write
        bitOffset: 16
        bitWidth: 1
      - name: CROSS_RESULT
        description: If 1, feed the opposite lane's result into this lane's 
          accumulator on POP.
        access: read-write
        bitOffset: 17
        bitWidth: 1
      - name: ADD_RAW
        description: If 1, mask + shift is bypassed for LANE1 result. This does 
          not affect FULL result.
        access: read-write
        bitOffset: 18
        bitWidth: 1
      - name: FORCE_MSB
        description: "ORed into bits 29:28 of the lane result presented to the processor
          on the bus. \n                            No effect on the internal 32-bit
          datapath. Handy for using a lane to generate sequence \n               \
          \             of pointers into flash or SRAM."
        access: read-write
        bitOffset: 19
        bitWidth: 2
  - name: INTERP1_ACCUM0_ADD
    addressOffset: 244
    description: "Values written here are atomically added to ACCUM0 \n          \
      \          Reading yields lane 0's raw shift and mask value (BASE0 not added)."
    resetValue: 0
    fields:
      - name: INTERP1_ACCUM0_ADD
        access: read-write
        bitOffset: 0
        bitWidth: 24
  - name: INTERP1_ACCUM1_ADD
    addressOffset: 248
    description: "Values written here are atomically added to ACCUM1 \n          \
      \          Reading yields lane 1's raw shift and mask value (BASE1 not added)."
    resetValue: 0
    fields:
      - name: INTERP1_ACCUM1_ADD
        access: read-write
        bitOffset: 0
        bitWidth: 24
  - name: INTERP1_BASE_1AND0
    addressOffset: 252
    description: "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\
      \ \n                    Each half is sign-extended to 32 bits if that lane's
      SIGNED flag is set."
    resetValue: 0
    fields:
      - name: INTERP1_BASE_1AND0
        access: write-only
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK0
    addressOffset: 256
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK0
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK1
    addressOffset: 260
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK1
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK2
    addressOffset: 264
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK2
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK3
    addressOffset: 268
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK3
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK4
    addressOffset: 272
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK4
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK5
    addressOffset: 276
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK5
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK6
    addressOffset: 280
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK6
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK7
    addressOffset: 284
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK7
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK8
    addressOffset: 288
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK8
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK9
    addressOffset: 292
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK9
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK10
    addressOffset: 296
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK10
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK11
    addressOffset: 300
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK11
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK12
    addressOffset: 304
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK12
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK13
    addressOffset: 308
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK13
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK14
    addressOffset: 312
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK14
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK15
    addressOffset: 316
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK15
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK16
    addressOffset: 320
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK16
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK17
    addressOffset: 324
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK17
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK18
    addressOffset: 328
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK18
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK19
    addressOffset: 332
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK19
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK20
    addressOffset: 336
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK20
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK21
    addressOffset: 340
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK21
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK22
    addressOffset: 344
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK22
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK23
    addressOffset: 348
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK23
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK24
    addressOffset: 352
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK24
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK25
    addressOffset: 356
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK25
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK26
    addressOffset: 360
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK26
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK27
    addressOffset: 364
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK27
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK28
    addressOffset: 368
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK28
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK29
    addressOffset: 372
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK29
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK30
    addressOffset: 376
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK30
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
  - name: SPINLOCK31
    addressOffset: 380
    description: "Reading from a spinlock address will: \n                    - Return
      0 if lock is already locked \n                    - Otherwise return nonzero,
      and simultaneously claim the lock\n\n                    Writing (any value)
      releases the lock. \n                    If core 0 and core 1 attempt to claim
      the same lock simultaneously, core 0 wins. \n                    The value returned
      on success is 0x1 << lock number."
    resetValue: 0
    fields:
      - name: SPINLOCK31
        access: read-write
        readAction: modify
        bitOffset: 0
        bitWidth: 32
interrupts:
  - name: SIO_IRQ_PROC0
  - name: SIO_IRQ_PROC1
addressBlocks:
  - offset: 0
    size: 384
    usage: registers
