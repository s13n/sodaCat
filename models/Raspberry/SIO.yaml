name: SIO
description: Fused peripheral template for SIO (RP2040) and SIO (RP2350).
parameters: []
variants:
  RP2040: {}
  RP2350: {}
registers:
- name: CPUID
  description: Processor core identifier
  resetMask: 0
  fields:
  - name: CPUID
    description: Value is 0 when read from processor core 0, and 1 when read from
      processor core 1.
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 0
- name: FIFO_RD
  description: Read access to this core's RX FIFO
  resetMask: 0
  fields:
  - name: FIFO_RD
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 88
- name: FIFO_ST
  description: "Status register for inter-core FIFOs (mailboxes). \n             \
    \       There is one FIFO in the core 0 -> core 1 direction, and one core 1 ->\
    \ core 0. Both are 32 bits wide and 8 words deep. \n                    Core 0\
    \ can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO\
    \ (TX). \n                    Core 1 can see the read side of the 0->1 FIFO (RX),\
    \ and the write side of 1->0 FIFO (TX). \n                    The SIO IRQ for\
    \ each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register."
  resetValue: 2
  fields:
  - name: VLD
    description: Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is
      valid)
    access: read-only
    bitOffset: 0
    bitWidth: 1
  - name: RDY
    description: Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is
      ready for more data)
    access: read-only
    bitOffset: 1
    bitWidth: 1
  - name: WOF
    description: Sticky flag indicating the TX FIFO was written when full. This write
      was ignored by the FIFO.
    access: read-write
    modifiedWriteValues: oneToClear
    bitOffset: 2
    bitWidth: 1
  - name: ROE
    description: Sticky flag indicating the RX FIFO was read when empty. This read
      was ignored by the FIFO.
    access: read-write
    modifiedWriteValues: oneToClear
    bitOffset: 3
    bitWidth: 1
  addressOffset: 80
- name: FIFO_WR
  description: Write access to this core's TX FIFO
  resetValue: 0
  fields:
  - name: FIFO_WR
    access: write-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 84
- name: GPIO_HI_IN
  description: Input value for QSPI pins
  resetValue: 0
  fields:
  - name: GPIO_HI_IN
    description: 'Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2,
      SD3'
    access: read-only
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    description: Input value on GPIO32...47
    access: read-only
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    description: Input value on USB D+ pin
    access: read-only
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    description: Input value on USB D- pin
    access: read-only
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    description: Input value on QSPI SCK pin
    access: read-only
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    description: Input value on QSPI CSn pin
    access: read-only
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    description: Input value on QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
    access: read-only
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 8
- name: GPIO_HI_OE
  description: QSPI output enable
  resetValue: 0
  fields:
  - name: GPIO_HI_OE
    description: "Set output enable (1/0 -> output/input) for QSPI IO0...5. \n   \
      \                         Reading back gives the last value written. \n    \
      \                        If core 0 and core 1 both write to GPIO_HI_OE simultaneously\
      \ (or to a SET/CLR/XOR alias), \n                            the result is as\
      \ though the write from core 0 took place first, \n                        \
      \    and the write from core 1 was then applied to that intermediate result."
    access: read-write
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    description: Output enable value for GPIO32...47
    access: read-write
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    description: Output enable value for USB D+ pin
    access: read-write
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    description: Output enable value for USB D- pin
    access: read-write
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    description: Output enable value for QSPI SCK pin
    access: read-write
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    description: Output enable value for QSPI CSn pin
    access: read-write
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    description: Output enable value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3
      pins
    access: read-write
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 64
- name: GPIO_HI_OE_CLR
  description: QSPI output enable clear
  resetValue: 0
  fields:
  - name: GPIO_HI_OE_CLR
    description: Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    access: write-only
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    access: write-only
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    access: write-only
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    access: write-only
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    access: write-only
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    access: write-only
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 72
- name: GPIO_HI_OE_SET
  description: QSPI output enable set
  resetValue: 0
  fields:
  - name: GPIO_HI_OE_SET
    description: Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    access: write-only
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    access: write-only
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    access: write-only
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    access: write-only
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    access: write-only
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    access: write-only
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 68
- name: GPIO_HI_OE_XOR
  description: QSPI output enable XOR
  resetValue: 0
  fields:
  - name: GPIO_HI_OE_XOR
    description: Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^=
      wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    access: write-only
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    access: write-only
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    access: write-only
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    access: write-only
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    access: write-only
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    access: write-only
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 76
- name: GPIO_HI_OUT
  description: QSPI output value
  resetValue: 0
  fields:
  - name: GPIO_HI_OUT
    description: "Set output level (1/0 -> high/low) for QSPI IO0...5. \n        \
      \                    Reading back gives the last value written, NOT the input\
      \ value from the pins. \n                            If core 0 and core 1 both\
      \ write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), \n      \
      \                      the result is as though the write from core 0 took place\
      \ first, \n                            and the write from core 1 was then applied\
      \ to that intermediate result."
    access: read-write
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    description: Output value for GPIO32...47
    access: read-write
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    description: Output value for USB D+ pin
    access: read-write
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    description: Output value for USB D- pin
    access: read-write
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    description: Output value for QSPI SCK pin
    access: read-write
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    description: Output value for QSPI CSn pin
    access: read-write
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    description: Output value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
    access: read-write
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 48
- name: GPIO_HI_OUT_CLR
  description: QSPI output value clear
  resetValue: 0
  fields:
  - name: GPIO_HI_OUT_CLR
    description: Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &=
      ~wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    access: write-only
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    access: write-only
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    access: write-only
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    access: write-only
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    access: write-only
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    access: write-only
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 56
- name: GPIO_HI_OUT_SET
  description: QSPI output value set
  resetValue: 0
  fields:
  - name: GPIO_HI_OUT_SET
    description: Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    access: write-only
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    access: write-only
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    access: write-only
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    access: write-only
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    access: write-only
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    access: write-only
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 52
- name: GPIO_HI_OUT_XOR
  description: QSPI output value XOR
  resetValue: 0
  fields:
  - name: GPIO_HI_OUT_XOR
    description: Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^=
      wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 6
    present_when: variant == 'RP2040'
  - name: GPIO
    access: write-only
    bitOffset: 0
    bitWidth: 16
    present_when: variant == 'RP2350'
  - name: USB_DP
    access: write-only
    bitOffset: 24
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: USB_DM
    access: write-only
    bitOffset: 25
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SCK
    access: write-only
    bitOffset: 26
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_CSN
    access: write-only
    bitOffset: 27
    bitWidth: 1
    present_when: variant == 'RP2350'
  - name: QSPI_SD
    access: write-only
    bitOffset: 28
    bitWidth: 4
    present_when: variant == 'RP2350'
  addressOffset: 60
- name: GPIO_IN
  description: Input value for GPIO pins
  resetValue: 0
  fields:
  - name: GPIO_IN
    description: Input value for GPIO0...29
    access: read-only
    bitOffset: 0
    bitWidth: 30
  addressOffset: 4
- name: GPIO_OE
  description: GPIO output enable
  resetValue: 0
  fields:
  - name: GPIO_OE
    description: "Set output enable (1/0 -> output/input) for GPIO0...29. \n     \
      \                       Reading back gives the last value written. \n      \
      \                      If core 0 and core 1 both write to GPIO_OE simultaneously\
      \ (or to a SET/CLR/XOR alias), \n                            the result is as\
      \ though the write from core 0 took place first, \n                        \
      \    and the write from core 1 was then applied to that intermediate result."
    access: read-write
    bitOffset: 0
    bitWidth: 30
  addressOffset: 32
- name: GPIO_OE_CLR
  description: GPIO output enable clear
  resetValue: 0
  fields:
  - name: GPIO_OE_CLR
    description: Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 30
  addressOffset: 40
- name: GPIO_OE_SET
  description: GPIO output enable set
  resetValue: 0
  fields:
  - name: GPIO_OE_SET
    description: Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 30
  addressOffset: 36
- name: GPIO_OE_XOR
  description: GPIO output enable XOR
  resetValue: 0
  fields:
  - name: GPIO_OE_XOR
    description: Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 30
  addressOffset: 44
- name: GPIO_OUT
  description: GPIO output value
  resetValue: 0
  fields:
  - name: GPIO_OUT
    description: "Set output level (1/0 -> high/low) for GPIO0...29. \n          \
      \                  Reading back gives the last value written, NOT the input\
      \ value from the pins. \n                            If core 0 and core 1 both\
      \ write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias), \n         \
      \                   the result is as though the write from core 0 took place\
      \ first, \n                            and the write from core 1 was then applied\
      \ to that intermediate result."
    access: read-write
    bitOffset: 0
    bitWidth: 30
  addressOffset: 16
- name: GPIO_OUT_CLR
  description: GPIO output value clear
  resetValue: 0
  fields:
  - name: GPIO_OUT_CLR
    description: Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= ~wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 30
  addressOffset: 24
- name: GPIO_OUT_SET
  description: GPIO output value set
  resetValue: 0
  fields:
  - name: GPIO_OUT_SET
    description: Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 30
  addressOffset: 20
- name: GPIO_OUT_XOR
  description: GPIO output value XOR
  resetValue: 0
  fields:
  - name: GPIO_OUT_XOR
    description: Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`
    access: write-only
    bitOffset: 0
    bitWidth: 30
  addressOffset: 28
- name: INTERP0_ACCUM0
  description: Read/write access to accumulator 0
  resetValue: 0
  fields:
  - name: INTERP0_ACCUM0
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 128
- name: INTERP0_ACCUM0_ADD
  description: "Values written here are atomically added to ACCUM0 \n            \
    \        Reading yields lane 0's raw shift and mask value (BASE0 not added)."
  resetValue: 0
  fields:
  - name: INTERP0_ACCUM0_ADD
    access: read-write
    bitOffset: 0
    bitWidth: 24
  addressOffset: 180
- name: INTERP0_ACCUM1
  description: Read/write access to accumulator 1
  resetValue: 0
  fields:
  - name: INTERP0_ACCUM1
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 132
- name: INTERP0_ACCUM1_ADD
  description: "Values written here are atomically added to ACCUM1 \n            \
    \        Reading yields lane 1's raw shift and mask value (BASE1 not added)."
  resetValue: 0
  fields:
  - name: INTERP0_ACCUM1_ADD
    access: read-write
    bitOffset: 0
    bitWidth: 24
  addressOffset: 184
- name: INTERP0_BASE0
  description: Read/write access to BASE0 register.
  resetValue: 0
  fields:
  - name: INTERP0_BASE0
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 136
- name: INTERP0_BASE1
  description: Read/write access to BASE1 register.
  resetValue: 0
  fields:
  - name: INTERP0_BASE1
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 140
- name: INTERP0_BASE2
  description: Read/write access to BASE2 register.
  resetValue: 0
  fields:
  - name: INTERP0_BASE2
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 144
- name: INTERP0_BASE_1AND0
  description: "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\
    \ \n                    Each half is sign-extended to 32 bits if that lane's SIGNED\
    \ flag is set."
  resetValue: 0
  fields:
  - name: INTERP0_BASE_1AND0
    access: write-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 188
- name: INTERP0_CTRL_LANE0
  description: Control register for lane 0
  resetValue: 0
  fields:
  - name: SHIFT
    description: Logical right-shift applied to accumulator before masking
    access: read-write
    bitOffset: 0
    bitWidth: 5
  - name: MASK_LSB
    description: The least-significant bit allowed to pass by the mask (inclusive)
    access: read-write
    bitOffset: 5
    bitWidth: 5
  - name: MASK_MSB
    description: "The most-significant bit allowed to pass by the mask (inclusive)\
      \ \n                            Setting MSB < LSB may cause chip to turn inside-out"
    access: read-write
    bitOffset: 10
    bitWidth: 5
  - name: SIGNED
    description: "If SIGNED is set, the shifted and masked accumulator value is sign-extended\
      \ to 32 bits \n                            before adding to BASE0, and LANE0\
      \ PEEK/POP appear extended to 32 bits when read by processor."
    access: read-write
    bitOffset: 15
    bitWidth: 1
  - name: CROSS_INPUT
    description: "If 1, feed the opposite lane's accumulator into this lane's shift\
      \ + mask hardware. \n                            Takes effect even if ADD_RAW\
      \ is set (the CROSS_INPUT mux is before the shift+mask bypass)"
    access: read-write
    bitOffset: 16
    bitWidth: 1
  - name: CROSS_RESULT
    description: If 1, feed the opposite lane's result into this lane's accumulator
      on POP.
    access: read-write
    bitOffset: 17
    bitWidth: 1
  - name: ADD_RAW
    description: If 1, mask + shift is bypassed for LANE0 result. This does not affect
      FULL result.
    access: read-write
    bitOffset: 18
    bitWidth: 1
  - name: FORCE_MSB
    description: "ORed into bits 29:28 of the lane result presented to the processor\
      \ on the bus. \n                            No effect on the internal 32-bit\
      \ datapath. Handy for using a lane to generate sequence \n                 \
      \           of pointers into flash or SRAM."
    access: read-write
    bitOffset: 19
    bitWidth: 2
  - name: BLEND
    description: "Only present on INTERP0 on each core. If BLEND mode is enabled:\
      \ \n                            - LANE1 result is a linear interpolation between\
      \ BASE0 and BASE1, controlled \n                            by the 8 LSBs of\
      \ lane 1 shift and mask value (a fractional number between \n              \
      \              0 and 255/256ths) \n                            - LANE0 result\
      \ does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value)\
      \ \n                            - FULL result does not have lane 1 shift+mask\
      \ value added (BASE2 + lane 0 shift+mask) \n                            LANE1\
      \ SIGNED flag controls whether the interpolation is signed or unsigned."
    access: read-write
    bitOffset: 21
    bitWidth: 1
  - name: OVERF0
    description: Indicates if any masked-off MSBs in ACCUM0 are set.
    access: read-only
    bitOffset: 23
    bitWidth: 1
  - name: OVERF1
    description: Indicates if any masked-off MSBs in ACCUM1 are set.
    access: read-only
    bitOffset: 24
    bitWidth: 1
  - name: OVERF
    description: Set if either OVERF0 or OVERF1 is set.
    access: read-only
    bitOffset: 25
    bitWidth: 1
  addressOffset: 172
- name: INTERP0_CTRL_LANE1
  description: Control register for lane 1
  resetValue: 0
  fields:
  - name: SHIFT
    description: Logical right-shift applied to accumulator before masking
    access: read-write
    bitOffset: 0
    bitWidth: 5
  - name: MASK_LSB
    description: The least-significant bit allowed to pass by the mask (inclusive)
    access: read-write
    bitOffset: 5
    bitWidth: 5
  - name: MASK_MSB
    description: "The most-significant bit allowed to pass by the mask (inclusive)\
      \ \n                            Setting MSB < LSB may cause chip to turn inside-out"
    access: read-write
    bitOffset: 10
    bitWidth: 5
  - name: SIGNED
    description: "If SIGNED is set, the shifted and masked accumulator value is sign-extended\
      \ to 32 bits \n                            before adding to BASE1, and LANE1\
      \ PEEK/POP appear extended to 32 bits when read by processor."
    access: read-write
    bitOffset: 15
    bitWidth: 1
  - name: CROSS_INPUT
    description: "If 1, feed the opposite lane's accumulator into this lane's shift\
      \ + mask hardware. \n                            Takes effect even if ADD_RAW\
      \ is set (the CROSS_INPUT mux is before the shift+mask bypass)"
    access: read-write
    bitOffset: 16
    bitWidth: 1
  - name: CROSS_RESULT
    description: If 1, feed the opposite lane's result into this lane's accumulator
      on POP.
    access: read-write
    bitOffset: 17
    bitWidth: 1
  - name: ADD_RAW
    description: If 1, mask + shift is bypassed for LANE1 result. This does not affect
      FULL result.
    access: read-write
    bitOffset: 18
    bitWidth: 1
  - name: FORCE_MSB
    description: "ORed into bits 29:28 of the lane result presented to the processor\
      \ on the bus. \n                            No effect on the internal 32-bit\
      \ datapath. Handy for using a lane to generate sequence \n                 \
      \           of pointers into flash or SRAM."
    access: read-write
    bitOffset: 19
    bitWidth: 2
  addressOffset: 176
- name: INTERP0_PEEK_FULL
  description: Read FULL result, without altering any internal state (PEEK).
  resetValue: 0
  fields:
  - name: INTERP0_PEEK_FULL
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 168
- name: INTERP0_PEEK_LANE0
  description: Read LANE0 result, without altering any internal state (PEEK).
  resetValue: 0
  fields:
  - name: INTERP0_PEEK_LANE0
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 160
- name: INTERP0_PEEK_LANE1
  description: Read LANE1 result, without altering any internal state (PEEK).
  resetValue: 0
  fields:
  - name: INTERP0_PEEK_LANE1
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 164
- name: INTERP0_POP_FULL
  description: Read FULL result, and simultaneously write lane results to both accumulators
    (POP).
  resetValue: 0
  fields:
  - name: INTERP0_POP_FULL
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 156
- name: INTERP0_POP_LANE0
  description: Read LANE0 result, and simultaneously write lane results to both accumulators
    (POP).
  resetValue: 0
  fields:
  - name: INTERP0_POP_LANE0
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 148
- name: INTERP0_POP_LANE1
  description: Read LANE1 result, and simultaneously write lane results to both accumulators
    (POP).
  resetValue: 0
  fields:
  - name: INTERP0_POP_LANE1
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 152
- name: INTERP1_ACCUM0
  description: Read/write access to accumulator 0
  resetValue: 0
  fields:
  - name: INTERP1_ACCUM0
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 192
- name: INTERP1_ACCUM0_ADD
  description: "Values written here are atomically added to ACCUM0 \n            \
    \        Reading yields lane 0's raw shift and mask value (BASE0 not added)."
  resetValue: 0
  fields:
  - name: INTERP1_ACCUM0_ADD
    access: read-write
    bitOffset: 0
    bitWidth: 24
  addressOffset: 244
- name: INTERP1_ACCUM1
  description: Read/write access to accumulator 1
  resetValue: 0
  fields:
  - name: INTERP1_ACCUM1
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 196
- name: INTERP1_ACCUM1_ADD
  description: "Values written here are atomically added to ACCUM1 \n            \
    \        Reading yields lane 1's raw shift and mask value (BASE1 not added)."
  resetValue: 0
  fields:
  - name: INTERP1_ACCUM1_ADD
    access: read-write
    bitOffset: 0
    bitWidth: 24
  addressOffset: 248
- name: INTERP1_BASE0
  description: Read/write access to BASE0 register.
  resetValue: 0
  fields:
  - name: INTERP1_BASE0
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 200
- name: INTERP1_BASE1
  description: Read/write access to BASE1 register.
  resetValue: 0
  fields:
  - name: INTERP1_BASE1
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 204
- name: INTERP1_BASE2
  description: Read/write access to BASE2 register.
  resetValue: 0
  fields:
  - name: INTERP1_BASE2
    access: read-write
    bitOffset: 0
    bitWidth: 32
  addressOffset: 208
- name: INTERP1_BASE_1AND0
  description: "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\
    \ \n                    Each half is sign-extended to 32 bits if that lane's SIGNED\
    \ flag is set."
  resetValue: 0
  fields:
  - name: INTERP1_BASE_1AND0
    access: write-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 252
- name: INTERP1_CTRL_LANE0
  description: Control register for lane 0
  resetValue: 0
  fields:
  - name: SHIFT
    description: Logical right-shift applied to accumulator before masking
    access: read-write
    bitOffset: 0
    bitWidth: 5
  - name: MASK_LSB
    description: The least-significant bit allowed to pass by the mask (inclusive)
    access: read-write
    bitOffset: 5
    bitWidth: 5
  - name: MASK_MSB
    description: "The most-significant bit allowed to pass by the mask (inclusive)\
      \ \n                            Setting MSB < LSB may cause chip to turn inside-out"
    access: read-write
    bitOffset: 10
    bitWidth: 5
  - name: SIGNED
    description: "If SIGNED is set, the shifted and masked accumulator value is sign-extended\
      \ to 32 bits \n                            before adding to BASE0, and LANE0\
      \ PEEK/POP appear extended to 32 bits when read by processor."
    access: read-write
    bitOffset: 15
    bitWidth: 1
  - name: CROSS_INPUT
    description: "If 1, feed the opposite lane's accumulator into this lane's shift\
      \ + mask hardware. \n                            Takes effect even if ADD_RAW\
      \ is set (the CROSS_INPUT mux is before the shift+mask bypass)"
    access: read-write
    bitOffset: 16
    bitWidth: 1
  - name: CROSS_RESULT
    description: If 1, feed the opposite lane's result into this lane's accumulator
      on POP.
    access: read-write
    bitOffset: 17
    bitWidth: 1
  - name: ADD_RAW
    description: If 1, mask + shift is bypassed for LANE0 result. This does not affect
      FULL result.
    access: read-write
    bitOffset: 18
    bitWidth: 1
  - name: FORCE_MSB
    description: "ORed into bits 29:28 of the lane result presented to the processor\
      \ on the bus. \n                            No effect on the internal 32-bit\
      \ datapath. Handy for using a lane to generate sequence \n                 \
      \           of pointers into flash or SRAM."
    access: read-write
    bitOffset: 19
    bitWidth: 2
  - name: CLAMP
    description: "Only present on INTERP1 on each core. If CLAMP mode is enabled:\
      \ \n                            - LANE0 result is shifted and masked ACCUM0,\
      \ clamped by a lower bound of \n                            BASE0 and an upper\
      \ bound of BASE1. \n                            - Signedness of these comparisons\
      \ is determined by LANE0_CTRL_SIGNED"
    access: read-write
    bitOffset: 22
    bitWidth: 1
  - name: OVERF0
    description: Indicates if any masked-off MSBs in ACCUM0 are set.
    access: read-only
    bitOffset: 23
    bitWidth: 1
  - name: OVERF1
    description: Indicates if any masked-off MSBs in ACCUM1 are set.
    access: read-only
    bitOffset: 24
    bitWidth: 1
  - name: OVERF
    description: Set if either OVERF0 or OVERF1 is set.
    access: read-only
    bitOffset: 25
    bitWidth: 1
  addressOffset: 236
- name: INTERP1_CTRL_LANE1
  description: Control register for lane 1
  resetValue: 0
  fields:
  - name: SHIFT
    description: Logical right-shift applied to accumulator before masking
    access: read-write
    bitOffset: 0
    bitWidth: 5
  - name: MASK_LSB
    description: The least-significant bit allowed to pass by the mask (inclusive)
    access: read-write
    bitOffset: 5
    bitWidth: 5
  - name: MASK_MSB
    description: "The most-significant bit allowed to pass by the mask (inclusive)\
      \ \n                            Setting MSB < LSB may cause chip to turn inside-out"
    access: read-write
    bitOffset: 10
    bitWidth: 5
  - name: SIGNED
    description: "If SIGNED is set, the shifted and masked accumulator value is sign-extended\
      \ to 32 bits \n                            before adding to BASE1, and LANE1\
      \ PEEK/POP appear extended to 32 bits when read by processor."
    access: read-write
    bitOffset: 15
    bitWidth: 1
  - name: CROSS_INPUT
    description: "If 1, feed the opposite lane's accumulator into this lane's shift\
      \ + mask hardware. \n                            Takes effect even if ADD_RAW\
      \ is set (the CROSS_INPUT mux is before the shift+mask bypass)"
    access: read-write
    bitOffset: 16
    bitWidth: 1
  - name: CROSS_RESULT
    description: If 1, feed the opposite lane's result into this lane's accumulator
      on POP.
    access: read-write
    bitOffset: 17
    bitWidth: 1
  - name: ADD_RAW
    description: If 1, mask + shift is bypassed for LANE1 result. This does not affect
      FULL result.
    access: read-write
    bitOffset: 18
    bitWidth: 1
  - name: FORCE_MSB
    description: "ORed into bits 29:28 of the lane result presented to the processor\
      \ on the bus. \n                            No effect on the internal 32-bit\
      \ datapath. Handy for using a lane to generate sequence \n                 \
      \           of pointers into flash or SRAM."
    access: read-write
    bitOffset: 19
    bitWidth: 2
  addressOffset: 240
- name: INTERP1_PEEK_FULL
  description: Read FULL result, without altering any internal state (PEEK).
  resetValue: 0
  fields:
  - name: INTERP1_PEEK_FULL
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 232
- name: INTERP1_PEEK_LANE0
  description: Read LANE0 result, without altering any internal state (PEEK).
  resetValue: 0
  fields:
  - name: INTERP1_PEEK_LANE0
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 224
- name: INTERP1_PEEK_LANE1
  description: Read LANE1 result, without altering any internal state (PEEK).
  resetValue: 0
  fields:
  - name: INTERP1_PEEK_LANE1
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 228
- name: INTERP1_POP_FULL
  description: Read FULL result, and simultaneously write lane results to both accumulators
    (POP).
  resetValue: 0
  fields:
  - name: INTERP1_POP_FULL
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 220
- name: INTERP1_POP_LANE0
  description: Read LANE0 result, and simultaneously write lane results to both accumulators
    (POP).
  resetValue: 0
  fields:
  - name: INTERP1_POP_LANE0
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 212
- name: INTERP1_POP_LANE1
  description: Read LANE1 result, and simultaneously write lane results to both accumulators
    (POP).
  resetValue: 0
  fields:
  - name: INTERP1_POP_LANE1
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 216
- name: SPINLOCK0
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK0
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 256
- name: SPINLOCK1
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK1
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 260
- name: SPINLOCK10
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK10
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 296
- name: SPINLOCK11
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK11
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 300
- name: SPINLOCK12
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK12
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 304
- name: SPINLOCK13
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK13
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 308
- name: SPINLOCK14
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK14
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 312
- name: SPINLOCK15
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK15
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 316
- name: SPINLOCK16
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK16
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 320
- name: SPINLOCK17
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK17
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 324
- name: SPINLOCK18
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK18
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 328
- name: SPINLOCK19
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK19
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 332
- name: SPINLOCK2
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK2
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 264
- name: SPINLOCK20
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK20
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 336
- name: SPINLOCK21
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK21
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 340
- name: SPINLOCK22
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK22
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 344
- name: SPINLOCK23
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK23
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 348
- name: SPINLOCK24
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK24
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 352
- name: SPINLOCK25
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK25
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 356
- name: SPINLOCK26
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK26
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 360
- name: SPINLOCK27
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK27
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 364
- name: SPINLOCK28
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK28
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 368
- name: SPINLOCK29
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK29
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 372
- name: SPINLOCK3
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK3
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 268
- name: SPINLOCK30
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK30
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 376
- name: SPINLOCK31
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK31
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 380
- name: SPINLOCK4
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK4
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 272
- name: SPINLOCK5
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK5
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 276
- name: SPINLOCK6
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK6
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 280
- name: SPINLOCK7
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK7
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 284
- name: SPINLOCK8
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK8
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 288
- name: SPINLOCK9
  description: "Reading from a spinlock address will: \n                    - Return\
    \ 0 if lock is already locked \n                    - Otherwise return nonzero,\
    \ and simultaneously claim the lock\n\n                    Writing (any value)\
    \ releases the lock. \n                    If core 0 and core 1 attempt to claim\
    \ the same lock simultaneously, core 0 wins. \n                    The value returned\
    \ on success is 0x1 << lock number."
  resetValue: 0
  fields:
  - name: SPINLOCK9
    access: read-write
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  addressOffset: 292
- name: SPINLOCK_ST
  description: "Spinlock state \n                    A bitmap containing the state\
    \ of all 32 spinlocks (1=locked). \n                    Mainly intended for debugging."
  resetValue: 0
  fields:
  - name: SPINLOCK_ST
    access: read-only
    bitOffset: 0
    bitWidth: 32
  addressOffset: 92
- name: DIV_CSR
  description: Control and status register for divider.
  resetValue: 1
  fields:
  - name: READY
    description: "Reads as 0 when a calculation is in progress, 1 otherwise. \n  \
      \                          Writing an operand (xDIVIDEND, xDIVISOR) will immediately\
      \ start a new calculation, no \n                            matter if one is\
      \ already in progress. \n                            Writing to a result register\
      \ will immediately terminate any in-progress calculation \n                \
      \            and set the READY and DIRTY flags."
    access: read-only
    bitOffset: 0
    bitWidth: 1
  - name: DIRTY
    description: "Changes to 1 when any register is written, and back to 0 when QUOTIENT\
      \ is read. \n                            Software can use this flag to make\
      \ save/restore more efficient (skip if not DIRTY). \n                      \
      \      If the flag is used in this way, it's recommended to either read QUOTIENT\
      \ only, \n                            or REMAINDER and then QUOTIENT, to prevent\
      \ data loss on context switch."
    access: read-only
    bitOffset: 1
    bitWidth: 1
  present_when: variant == 'RP2040'
  addressOffset: 120
- name: DIV_QUOTIENT
  description: "Divider result quotient \n                    The result of `DIVIDEND\
    \ / DIVISOR` (division). Contents undefined while CSR_READY is low. \n       \
    \             For signed calculations, QUOTIENT is negative when the signs of\
    \ DIVIDEND and DIVISOR differ. \n                    This register can be written\
    \ to directly, for context save/restore purposes. This halts any \n          \
    \          in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.\
    \ \n                    Reading from QUOTIENT clears the CSR_DIRTY flag, so should\
    \ read results in the order \n                    REMAINDER, QUOTIENT if CSR_DIRTY\
    \ is used."
  resetValue: 0
  fields:
  - name: DIV_QUOTIENT
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2040'
  addressOffset: 112
- name: DIV_REMAINDER
  description: "Divider result remainder \n                    The result of `DIVIDEND\
    \ % DIVISOR` (modulo). Contents undefined while CSR_READY is low. \n         \
    \           For signed calculations, REMAINDER is negative only when DIVIDEND\
    \ is negative. \n                    This register can be written to directly,\
    \ for context save/restore purposes. This halts any \n                    in-progress\
    \ calculation and sets the CSR_READY and CSR_DIRTY flags."
  resetValue: 0
  fields:
  - name: DIV_REMAINDER
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2040'
  addressOffset: 116
- name: DIV_SDIVIDEND
  description: "Divider signed dividend \n                    The same as UDIVIDEND,\
    \ but starts a signed calculation, rather than unsigned."
  resetValue: 0
  fields:
  - name: DIV_SDIVIDEND
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2040'
  addressOffset: 104
- name: DIV_SDIVISOR
  description: "Divider signed divisor \n                    The same as UDIVISOR,\
    \ but starts a signed calculation, rather than unsigned."
  resetValue: 0
  fields:
  - name: DIV_SDIVISOR
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2040'
  addressOffset: 108
- name: DIV_UDIVIDEND
  description: "Divider unsigned dividend \n                    Write to the DIVIDEND\
    \ operand of the divider, i.e. the p in `p / q`. \n                    Any operand\
    \ write starts a new calculation. The results appear in QUOTIENT, REMAINDER. \n\
    \                    UDIVIDEND/SDIVIDEND are aliases of the same internal register.\
    \ The U alias starts an \n                    unsigned calculation, and the S\
    \ alias starts a signed calculation."
  resetValue: 0
  fields:
  - name: DIV_UDIVIDEND
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2040'
  addressOffset: 96
- name: DIV_UDIVISOR
  description: "Divider unsigned divisor \n                    Write to the DIVISOR\
    \ operand of the divider, i.e. the q in `p / q`. \n                    Any operand\
    \ write starts a new calculation. The results appear in QUOTIENT, REMAINDER. \n\
    \                    UDIVISOR/SDIVISOR are aliases of the same internal register.\
    \ The U alias starts an \n                    unsigned calculation, and the S\
    \ alias starts a signed calculation."
  resetValue: 0
  fields:
  - name: DIV_UDIVISOR
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2040'
  addressOffset: 100
- name: DOORBELL_IN_CLR
  description: "Check and acknowledge doorbells posted to this core. This core's doorbell\
    \ interrupt is asserted when any bit in this register is 1.\n\n              \
    \      Write 1 to each bit to clear that bit. The doorbell interrupt deasserts\
    \ once all bits are cleared. Read to get status of doorbells currently asserted\
    \ on this core."
  resetValue: 0
  fields:
  - name: DOORBELL_IN_CLR
    access: read-write
    modifiedWriteValues: oneToClear
    bitOffset: 0
    bitWidth: 8
  present_when: variant == 'RP2350'
  addressOffset: 396
- name: DOORBELL_IN_SET
  description: Write 1s to trigger doorbell interrupts on this core. Read to get status
    of doorbells currently asserted on this core.
  resetValue: 0
  fields:
  - name: DOORBELL_IN_SET
    access: read-write
    bitOffset: 0
    bitWidth: 8
  present_when: variant == 'RP2350'
  addressOffset: 392
- name: DOORBELL_OUT_CLR
  description: "Clear doorbells which have been posted to the opposite core. This\
    \ register is intended for debugging and initialisation purposes.\n\n        \
    \            Writing 1 to a bit in DOORBELL_OUT_CLR clears the corresponding bit\
    \ in DOORBELL_IN on the opposite core. Clearing all bits will cause that core's\
    \ doorbell interrupt to deassert. Since the usual order of events is for software\
    \ to send events using DOORBELL_OUT_SET, and acknowledge incoming events by writing\
    \ to DOORBELL_IN_CLR, this register should be used with caution to avoid race\
    \ conditions.\n\n                    Reading returns the status of the doorbells\
    \ currently asserted on the other core, i.e. is equivalent to that core reading\
    \ its own DOORBELL_IN status."
  resetValue: 0
  fields:
  - name: DOORBELL_OUT_CLR
    access: read-write
    modifiedWriteValues: oneToClear
    bitOffset: 0
    bitWidth: 8
  present_when: variant == 'RP2350'
  addressOffset: 388
- name: DOORBELL_OUT_SET
  description: "Trigger a doorbell interrupt on the opposite core.\n\n           \
    \         Write 1 to a bit to set the corresponding bit in DOORBELL_IN on the\
    \ opposite core. This raises the opposite core's doorbell interrupt.\n\n     \
    \               Read to get the status of the doorbells currently asserted on\
    \ the opposite core. This is equivalent to that core reading its own DOORBELL_IN\
    \ status."
  resetValue: 0
  fields:
  - name: DOORBELL_OUT_SET
    access: read-write
    bitOffset: 0
    bitWidth: 8
  present_when: variant == 'RP2350'
  addressOffset: 384
- name: MTIME
  description: Read/write access to the high half of RISC-V Machine-mode timer. This
    register is shared between both cores. If both cores write on the same cycle,
    core 1 takes precedence.
  resetValue: 0
  fields:
  - name: MTIME
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 432
- name: MTIMECMP
  description: "Low half of RISC-V Machine-mode timer comparator. This register is\
    \ core-local, i.e., each core gets a copy of this register, with the comparison\
    \ result routed to its own interrupt line.\n\n                    The timer interrupt\
    \ is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison\
    \ is unsigned, and performed on the full 64-bit values."
  resetValue: 4294967295
  fields:
  - name: MTIMECMP
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 440
- name: MTIMECMPH
  description: "High half of RISC-V Machine-mode timer comparator. This register is\
    \ core-local.\n\n                    The timer interrupt is asserted whenever\
    \ MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and\
    \ performed on the full 64-bit values."
  resetValue: 4294967295
  fields:
  - name: MTIMECMPH
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 444
- name: MTIMEH
  description: Read/write access to the high half of RISC-V Machine-mode timer. This
    register is shared between both cores. If both cores write on the same cycle,
    core 1 takes precedence.
  resetValue: 0
  fields:
  - name: MTIMEH
    access: read-write
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 436
- name: MTIME_CTRL
  description: "Control register for the RISC-V 64-bit Machine-mode timer. This timer\
    \ is only present in the Secure SIO, so is only accessible to an Arm core in Secure\
    \ mode or a RISC-V core in Machine mode.\n\n                    Note whilst this\
    \ timer follows the RISC-V privileged specification, it is equally usable by the\
    \ Arm cores. The interrupts are routed to normal system-level interrupt lines\
    \ as well as to the MIP.MTIP inputs on the RISC-V cores."
  resetValue: 13
  fields:
  - name: EN
    description: Timer enable bit. When 0, the timer will not increment automatically.
    access: read-write
    bitOffset: 0
    bitWidth: 1
  - name: FULLSPEED
    description: If 1, increment the timer every cycle (i.e. run directly from the
      system clock), rather than incrementing on the system-level timer tick input.
    access: read-write
    bitOffset: 1
    bitWidth: 1
  - name: DBGPAUSE_CORE0
    description: If 1, the timer pauses when core 0 is in the debug halt state.
    access: read-write
    bitOffset: 2
    bitWidth: 1
  - name: DBGPAUSE_CORE1
    description: If 1, the timer pauses when core 1 is in the debug halt state.
    access: read-write
    bitOffset: 3
    bitWidth: 1
  present_when: variant == 'RP2350'
  addressOffset: 420
- name: PERI_NONSEC
  description: "Detach certain core-local peripherals from Secure SIO, and attach\
    \ them to Non-secure SIO, so that Non-secure software can use them. Attempting\
    \ to access one of these peripherals from the Secure SIO when it is attached to\
    \ the Non-secure SIO, or vice versa, will generate a bus error.\n\n          \
    \          This register is per-core, and is only present on the Secure SIO.\n\
    \n                    Most SIO hardware is duplicated across the Secure and Non-secure\
    \ SIO, so is not listed in this register."
  resetValue: 0
  fields:
  - name: INTERP0
    description: If 1, detach interpolator 0 (of this core) from the Secure SIO, and
      attach to the Non-secure SIO.
    access: read-write
    bitOffset: 0
    bitWidth: 1
  - name: INTERP1
    description: If 1, detach interpolator 1 (of this core) from the Secure SIO, and
      attach to the Non-secure SIO.
    access: read-write
    bitOffset: 1
    bitWidth: 1
  - name: TMDS
    description: IF 1, detach TMDS encoder (of this core) from the Secure SIO, and
      attach to the Non-secure SIO.
    access: read-write
    bitOffset: 5
    bitWidth: 1
  present_when: variant == 'RP2350'
  addressOffset: 400
- name: RISCV_SOFTIRQ
  description: "Control the assertion of the standard software interrupt (MIP.MSIP)\
    \ on the RISC-V cores.\n\n                    Unlike the RISC-V timer, this interrupt\
    \ is not routed to a normal system-level interrupt line, so can not be used by\
    \ the Arm cores.\n\n                    It is safe for both cores to write to\
    \ this register on the same cycle. The set/clear effect is accumulated across\
    \ both cores, and then applied. If a flag is both set and cleared on the same\
    \ cycle, only the set takes effect."
  resetValue: 0
  fields:
  - name: CORE0_SET
    description: Write 1 to atomically set the core 0 software interrupt flag. Read
      to get the status of this flag.
    access: read-write
    bitOffset: 0
    bitWidth: 1
  - name: CORE1_SET
    description: Write 1 to atomically set the core 1 software interrupt flag. Read
      to get the status of this flag.
    access: read-write
    bitOffset: 1
    bitWidth: 1
  - name: CORE0_CLR
    description: Write 1 to atomically clear the core 0 software interrupt flag. Read
      to get the status of this flag.
    access: read-write
    bitOffset: 8
    bitWidth: 1
  - name: CORE1_CLR
    description: Write 1 to atomically clear the core 1 software interrupt flag. Read
      to get the status of this flag.
    access: read-write
    bitOffset: 9
    bitWidth: 1
  present_when: variant == 'RP2350'
  addressOffset: 416
- name: TMDS_CTRL
  description: Control register for TMDS encoder.
  resetValue: 0
  fields:
  - name: L0_ROT
    description: "Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits,\
      \ in order to get the MSB of the lane 0 (blue) colour data aligned with the\
      \ MSB of the 8-bit encoder input.\n\n                            For example,\
      \ for RGB565 (red most significant), blue is bits 4:0, so should be right-rotated\
      \ by 13 to align with bits 7:3 of the encoder input."
    access: read-write
    bitOffset: 0
    bitWidth: 4
  - name: L1_ROT
    description: "Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits,\
      \ in order to get the MSB of the lane 1 (green) colour data aligned with the\
      \ MSB of the 8-bit encoder input.\n\n                            For example,\
      \ for RGB565, green is bits 10:5, so should be right-rotated by 3 bits to align\
      \ with bits 7:2 of the encoder input."
    access: read-write
    bitOffset: 4
    bitWidth: 4
  - name: L2_ROT
    description: "Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits,\
      \ in order to get the MSB of the lane 2 (red) colour data aligned with the MSB\
      \ of the 8-bit encoder input.\n\n                            For example, for\
      \ RGB565 (red most significant), red is bits 15:11, so should be right-rotated\
      \ by 8 bits to align with bits 7:3 of the encoder input."
    access: read-write
    bitOffset: 8
    bitWidth: 4
  - name: L0_NBITS
    description: Number of valid colour MSBs for lane 0 (1-8 bits, encoded as 0 through
      7). Remaining LSBs are masked to 0 after the rotate.
    access: read-write
    bitOffset: 12
    bitWidth: 3
  - name: L1_NBITS
    description: Number of valid colour MSBs for lane 1 (1-8 bits, encoded as 0 through
      7). Remaining LSBs are masked to 0 after the rotate.
    access: read-write
    bitOffset: 15
    bitWidth: 3
  - name: L2_NBITS
    description: Number of valid colour MSBs for lane 2 (1-8 bits, encoded as 0 through
      7). Remaining LSBs are masked to 0 after the rotate.
    access: read-write
    bitOffset: 18
    bitWidth: 3
  - name: INTERLEAVE
    description: "Enable lane interleaving for reads of PEEK_SINGLE/POP_SINGLE.\n\n\
      \                            When interleaving is disabled, each of the 3 symbols\
      \ appears as a contiguous 10-bit field, with lane 0 being the least-significant\
      \ and starting at bit 0 of the register.\n\n                            When\
      \ interleaving is enabled, the symbols are packed into 5 chunks of 3 lanes times\
      \ 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per\
      \ lane, with lane 0 being the least significant."
    access: read-write
    bitOffset: 23
    bitWidth: 1
  - name: PIX_SHIFT
    description: "Shift applied to the colour data register with each read of a POP\
      \ alias register.\n\n                            Reading from the POP_SINGLE\
      \ register, or reading from the POP_DOUBLE register with PIX2_NOSHIFT set (for\
      \ pixel doubling), shifts by the indicated amount.\n\n                     \
      \       Reading from a POP_DOUBLE register when PIX2_NOSHIFT is clear will shift\
      \ by double the indicated amount. (Shift by 32 means no shift.)"
    access: read-write
    enumeratedValues:
    - name: '0'
      value: 0
      description: Do not shift the colour data register.
    - name: '1'
      value: 1
      description: Shift the colour data register by 1 bit
    - name: '2'
      value: 2
      description: Shift the colour data register by 2 bits
    - name: '4'
      value: 3
      description: Shift the colour data register by 4 bits
    - name: '8'
      value: 4
      description: Shift the colour data register by 8 bits
    - name: '16'
      value: 5
      description: Shift the colour data register by 16 bits
    bitOffset: 24
    bitWidth: 3
  - name: PIX2_NOSHIFT
    description: "When encoding two pixels's worth of symbols in one cycle (a read\
      \ of a PEEK/POP_DOUBLE register), the second encoder sees a shifted version\
      \ of the colour data register.\n\n                            This control disables\
      \ that shift, so that both encoder layers see the same pixel data. This is used\
      \ for pixel doubling."
    access: read-write
    bitOffset: 27
    bitWidth: 1
  - name: CLEAR_BALANCE
    description: Clear the running DC balance state of the TMDS encoders. This bit
      should be written once at the beginning of each scanline.
    access: write-only
    bitOffset: 28
    bitWidth: 1
  present_when: variant == 'RP2350'
  addressOffset: 448
- name: TMDS_PEEK_DOUBLE_L0
  description: "Get lane 0 of the encoding of two pixels' worth of colour data. Two\
    \ 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n         \
    \           The PEEK alias does not shift the colour register when read, but still\
    \ advances the lane 0 DC balance state. This is useful if all 3 lanes' worth of\
    \ encode are to be read at once, rather than processing the entire scanline for\
    \ one lane before moving to the next lane."
  resetValue: 0
  fields:
  - name: TMDS_PEEK_DOUBLE_L0
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 464
- name: TMDS_PEEK_DOUBLE_L1
  description: "Get lane 1 of the encoding of two pixels' worth of colour data. Two\
    \ 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n         \
    \           The PEEK alias does not shift the colour register when read, but still\
    \ advances the lane 1 DC balance state. This is useful if all 3 lanes' worth of\
    \ encode are to be read at once, rather than processing the entire scanline for\
    \ one lane before moving to the next lane."
  resetValue: 0
  fields:
  - name: TMDS_PEEK_DOUBLE_L1
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 472
- name: TMDS_PEEK_DOUBLE_L2
  description: "Get lane 2 of the encoding of two pixels' worth of colour data. Two\
    \ 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n         \
    \           The PEEK alias does not shift the colour register when read, but still\
    \ advances the lane 2 DC balance state. This is useful if all 3 lanes' worth of\
    \ encode are to be read at once, rather than processing the entire scanline for\
    \ one lane before moving to the next lane."
  resetValue: 0
  fields:
  - name: TMDS_PEEK_DOUBLE_L2
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 480
- name: TMDS_PEEK_SINGLE
  description: "Get the encoding of one pixel's worth of colour data, packed into\
    \ a 32-bit value (3x10-bit symbols).\n\n                    The PEEK alias does\
    \ not shift the colour register when read, but still advances the running DC balance\
    \ state of each encoder. This is useful for pixel doubling."
  resetValue: 0
  fields:
  - name: TMDS_PEEK_SINGLE
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 456
- name: TMDS_POP_DOUBLE_L0
  description: "Get lane 0 of the encoding of two pixels' worth of colour data. Two\
    \ 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n         \
    \           The POP alias shifts the colour register when read, according to the\
    \ values of PIX_SHIFT and PIX2_NOSHIFT."
  resetValue: 0
  fields:
  - name: TMDS_POP_DOUBLE_L0
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 468
- name: TMDS_POP_DOUBLE_L1
  description: "Get lane 1 of the encoding of two pixels' worth of colour data. Two\
    \ 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n         \
    \           The POP alias shifts the colour register when read, according to the\
    \ values of PIX_SHIFT and PIX2_NOSHIFT."
  resetValue: 0
  fields:
  - name: TMDS_POP_DOUBLE_L1
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 476
- name: TMDS_POP_DOUBLE_L2
  description: "Get lane 2 of the encoding of two pixels' worth of colour data. Two\
    \ 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n         \
    \           The POP alias shifts the colour register when read, according to the\
    \ values of PIX_SHIFT and PIX2_NOSHIFT."
  resetValue: 0
  fields:
  - name: TMDS_POP_DOUBLE_L2
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 484
- name: TMDS_POP_SINGLE
  description: "Get the encoding of one pixel's worth of colour data, packed into\
    \ a 32-bit value. The packing is 5 chunks of 3 lanes times 2 bits (30 bits total).\
    \ Each chunk contains two bits of a TMDS symbol per lane. This format is intended\
    \ for shifting out with the HSTX peripheral on RP2350.\n\n                   \
    \ The POP alias shifts the colour register when read, as well as advancing the\
    \ running DC balance state of each encoder."
  resetValue: 0
  fields:
  - name: TMDS_POP_SINGLE
    access: read-only
    readAction: modify
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 460
- name: TMDS_WDATA
  description: Write-only access to the TMDS colour data register.
  resetValue: 0
  fields:
  - name: TMDS_WDATA
    access: write-only
    bitOffset: 0
    bitWidth: 32
  present_when: variant == 'RP2350'
  addressOffset: 452
